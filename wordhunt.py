'''
Key Features: 
1. Multi stage game system with start screen, playing screen, and ending screen
2. OOP used by creation of button class with method isClicked, buttons used on start and end screen
3. End screen containing final score, words found, and a list of the top 5 highest scores of previous runs at the grame
4. Generation of a random board for each playthrough using most common english letters
5. Word formation through mouse drags, where the selected cell highlights with a green line in real time. Each word being
formed is tracked in app.currWord and displayed above the board. The path taken to create each word is tracked in app.currPath, 
to ensure no square can be hit twice, and to ensure each square is adjacent/diagonal using function isAdjacent. 
6. Cell selection uses a 70% hitbox to ensure diagonal selection is easy for the user to achieve
7. Words are validated by checking through a set containing the 20k most commonly found words in the english language. 

NOTE: These 20k words are not nearly enough to accurately check all words in the dictionary. Therefore, there are many words
that you may find on the board, which will not score any points because they are not common enough to be included in my list. 
I was unable to include a longer list of words without the project becoming very laggy, so I chose to keep this less diverse list
for the sake of playability. This problem could easily be fixed by important a more comprehensive dictionary and using an outside
platform like VSCode to mitigate lag

Grading Shortcuts: 
Each stage is pretty simple to get to without shortcuts. IF you want to get to the ending screen without waiting 30 seconds 
for the round to end, change the variable app.remaining in line 76 ans 228 to the shorter number of seconds you would like the game to run for.
'''


# Place your creative task here!
from cmu_graphics import *
import random
import math


# dictionary link: https://raw.githubusercontent.com/shubhaudipi/wordhunt/master/dictionary.txt
# 20k most common english words list found on github. using a full word list makes the game too laggy, 
# so you may find words that do not add to your score. 


# start image link: cmu://1103773/43553086/Gemini_Generated_Image_x4pzztx4pzztx4pz-removebg-preview.png
# image generated by gemini

def onAppStart(app):
    
    app.state = 'start'
    # for grid
    app.rows = 4
    app.cols = 4
    app.boardLeft = 60
    app.boardTop = 100
    app.boardWidth = 280

    
    app.boardHeight = 280
    app.cellBorderWidth = 2
    app.board = loadBoard(app.rows, app.cols)
    
    # mouse tracking
    app.currPath = []
    app.currWord = ''
    app.isDragging = False
    
    # word validation and scoring
    app.dictionary = loadDictionary()
    app.found = []
    app.score = 0
    app.numFound = 0
    
    # buttons
    # app.buttonList = []
    # app.button = Button(app, 150, 50, 50, 25)
    
    app.bg = rgb(230, 250, 230)

    app.highscores=[]
    app.playb=Button(app, 150, 325, 100, 50, 'PLAY')
    app.playagain=Button(app, 160, 320, 80, 25, "Play Again")
    
    # for timer
    app.remaining = 30
    app.stepsPerSecond = 10
    
# for timer
def onStep(app):
    if app.state=='playing' and app.remaining>0:
        app.remaining -= 0.1
        if app.remaining <= 0:
            app.remaining = 0
            endGame(app)
        

# drawing basic board
def redrawAll(app):
    drawRect(0, 0, app.width, app.height, fill=app.bg)
    
    if app.state=='start':
        drawStartScreen(app)
    elif app.state=='playing':
        drawPlayingScreen(app)
    elif app.state=='end':
        drawEndScreen(app)
    
def drawStartScreen(app):
    drawImage('titlegraphic.png', 100, 105, width=200, height=200)
    drawLabel('Drag across the board to form words.', 200, 35, size=15)
    drawLabel('Words must be 3+ letters using adjacent/diagonal tiles.', 200, 50, size = 15)
    drawLabel('The longer the word, the more points you gain.', 200, 65, size = 15)
    drawLabel('Find as many words as you can in 30 seconds!', 200, 80, size=15)
    
    app.playb.draw()

def drawPlayingScreen(app):
    drawBoard(app)
    drawBoardBorder(app)
    drawLines(app)
    
    if app.currWord != '':
        drawLabel(app.currWord, 200, 80, size=28, bold=True, fill='gray')
        
    drawLabel(app.score, 200, 30, size=28)
    drawLabel("Found: " + str(app.numFound), 350, 30, size=16)
    
    # timer
    drawLabel(f'Time: {int(app.remaining)}s', 50, 30, size=16, bold=True)
    
def drawEndScreen(app):
    drawRect(0, 0, app.width, app.height, fill='black', opacity=30)
    drawRect(40, 40, 320, 320, fill='white', border='darkGreen', borderWidth=2)
    drawLabel("Time's Up!", 200, 75, size=40, bold=True, fill='darkGreen')
    
    drawLabel(f'Final Score: {app.score}', 200, 120, size=28, bold=True, fill='black')
    drawLabel(f'Words Found: {app.numFound}', 200, 150, size=20, fill='black')
    
    # add leaderboard
    drawLabel('High Scores: ', 200, 190, size=18, bold=True, fill='darkGreen')
    y=210
    for i in range(len(app.highscores[:5])):
        drawLabel(f'{i+1}. {app.highscores[i]}', 200, y, size=16, fill='black')
        y += 20
    
    app.playagain.draw()
    
    
def drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            drawCell(app, row, col)

def drawBoardBorder(app):
    drawRect(app.boardLeft, app.boardTop, app.boardWidth, app.boardHeight, fill=None, border='black', borderWidth=2*app.cellBorderWidth)

def drawCell(app, row, col):
    cellLeft, cellTop = getCellLeftTop(app, row, col)
    cellWidth, cellHeight = getCellSize(app)
    drawRect(cellLeft, cellTop, cellWidth, cellHeight, fill=rgb(213, 245, 228), border='black', borderWidth=app.cellBorderWidth)
    drawLabel(app.board[row][col], cellLeft + cellWidth/2, cellTop + cellHeight/2, size=40, bold=True)

def getCellLeftTop(app, row, col):
    cellWidth, cellHeight = getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)
    
def getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)

# adding letters to the board
# using this letter frequency table of most common letters: https://pi.math.cornell.edu/~mec/2003-2004/cryptography/subs/frequencies.html
def loadBoard(rows, cols):
    letters = "EEEEEEEEEETTTTTTTAAAAAAAAOOOOOOIIIIIINNNNNSSSSRRRRRHHHHHHDDDDLLLLUUUCCCMMMFFYYWWGGPPBVKXQJZ"
    letterBoard = []
    for row in range(rows):
        letterBoard.append([])
        for col in range(cols):
            letterBoard[row].append(random.choice(letters))
    return letterBoard

# mouse tracking
def getCell(app, x, y):
    dx = x - app.boardLeft
    dy = y - app.boardTop
    cellWidth, cellHeight = getCellSize(app)
    row = math.floor(dy/cellHeight)
    col = math.floor(dx/cellWidth)
    
    cellCx = app.boardLeft + col*cellWidth + (cellWidth/2)
    cellCy = app.boardTop + row*cellHeight + (cellHeight/2)
    
    if row < 0 or row >= app.rows or col < 0 or col >= app.cols:
        return None 
        
    hitboxScale = 0.7
    hitboxWidth = (cellWidth*hitboxScale)/2
    hitboxHeight = (cellHeight*hitboxScale)/2
    
    if abs(x-cellCx) <= hitboxWidth and abs(y-cellCy) <= hitboxHeight:
        return (row, col)
        
    return None
    
def adjacent(last, next):
    row1, col1 = last
    row2, col2 = next
    return abs(row1-row2)<=1 and abs(col1-col2)<=1
    
def onMousePress(app, mouseX, mouseY):
    if app.state=='start':
        if app.playb.isClicked(mouseX, mouseY):
            startGame(app)
    elif app.state=='end':
        if app.playagain.isClicked(mouseX, mouseY):
            startGame(app)
    elif app.state =='playing':
        cell = getCell(app, mouseX, mouseY)
        if cell != None:
            row, col = cell
            app.isDragging = True
            app.currPath = [cell]
            app.currWord = app.board[row][col]

def startGame(app):
    app.state = 'playing'
    app.board = loadBoard(app.rows, app.cols)
    app.currPath = []
    app.currWord = ''
    app.isDragging = False
    app.found = []
    app.score = 0
    app.numFound = 0
    app.remaining = 30

def endGame(app):
    app.state = 'end'
    app.highscores.append(app.score)
    app.highscores.sort(reverse=True)
    app.highscores=app.highscores[:5]
    
def onMouseDrag(app, mouseX, mouseY):
    if app.isDragging and app.state=='playing':
        cell = getCell(app, mouseX, mouseY)
        if cell != None and cell not in app.currPath:
            if adjacent(app.currPath[-1], cell):
                app.currPath.append(cell)
                row, col = cell
                app.currWord += app.board[row][col]

def onMouseRelease(app, mouseX, mouseY):
    if app.isDragging and app.state=='playing':
        app.isDragging = False

        
        if isValidWord(app, app.currWord):
            app.found.append(app.currWord.lower())
            scoreWord(app, app.currWord)
            app.numFound += 1 # = len(app.found)
            print('Word formed: ' + app.currWord)
            
        app.currPath = []
        app.currWord = ''

        
# drawing path lines
def drawLines(app):
    if len(app.currPath) > 1:
        cellWidth, cellHeight = getCellSize(app)
        
        for i in range(len(app.currPath)-1):
            row1, col1 = app.currPath[i]
            row2, col2 = app.currPath[i+1]
            
            x1 = app.boardLeft + col1*cellWidth + cellWidth/2
            y1 = app.boardTop + row1*cellHeight + cellHeight/2
            x2 = app.boardLeft + col2*cellWidth + cellWidth/2
            y2 = app.boardTop + row2*cellHeight + cellHeight/2
            
            drawLine(x1, y1, x2, y2, fill='green', opacity=50, lineWidth=6)
    
    
# word validation
def isValidWord(app, word):
    if len(word.lower()) < 3:
        return False
    
    if word.lower() in app.found:
        return False
    
    if word.lower() not in app.dictionary:
        return False
    
    return True
    
# may change to letter-based scoring, with rarer letters being worth more
def scoreWord(app, word):
    scores = {3: 100, 4: 400, 5: 800, 6: 1400, 7: 2000}
    for k in scores:
        if len(word) == k:
            app.score += scores[k]
    if len(word) > 7:
        app.score += 2000 + (len(word)-7)*1000

    
class Button: 
    def __init__(self, app, left, top, width, height, label):
        self.app = app
        self.left = left
        self.top = top
        self.width = width
        self.height = height
        self.label = label
        self.pressed = False
        
    def draw(self):
        if self.pressed:
            drawRect(self.left, self.top, self.width, self.height, fill=rgb(239, 207, 148))
            drawLabel(self.label, self.left+self.width/2, self.top+self.height/2, size = 16)
        else:
            drawRect(self.left, self.top, self.width, self.height, fill=rgb(164, 221, 150))
            drawLabel(self.label, self.left+self.width/2, self.top+self.height/2, size = 16)

    def isClicked(self, mx, my):
        if self.left < mx < self.left + self.width and self.top < my < self.top + self.height:
            return True
        return False
            
def readFile(path):
    with open(path) as f:
        return f.read()

def loadDictionary():
    words = set()
    path = "20k.txt"
    with open(path, "r") as f:
        contents = f.read()
    
    for line in contents.split('\n'):
        word = line.strip().lower()
        if len(word) >= 3 and len(word) <= 7:
            words.add(word)
    
    return words
    
    
def main():
    runApp()

main()